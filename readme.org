#+title:Doom-emacs config
* Basic stuff
#+begin_src emacs-lisp :tangle yes
(add-to-list 'load-path "~/.config/doom/elisp")
#+end_src

  Yooooooooooo let's go

#+BEGIN_SRC emacs-lisp :tangle yes
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!


;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
(setq user-full-name "Thomas F. K. Jorna"
      user-mail-address "jorna@jtrialerror.com")
#+end_src
** ...
#+begin_src emacs-lisp :tangle yes

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/OneDrive/org-roam/"
      org-roam-directory "~/OneDrive/org-roam")

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type t)

;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;  .
#+end_src
* UI


** Theme
*** Nano

     Basic things you can keep in place without being locked into nano
  #+begin_src emacs-lisp :tangle no
(setq nano-font-family-monospaced "Overpass Mono")
(setq nano-font-family-proportional "Noto Serif")
(setq nano-font-size 13)

        ;(defvar nano-theme-light-var t)
(require 'disp-table)
(require 'nano-theme-dark)
(require 'nano-theme-light)
;(require 'nano-layout)
;(require 'nano-base-colors)
(require 'nano-faces)
(nano-faces)
  #+end_src

  The real fun begins here
  #+begin_src emacs-lisp :tangle no
(require 'nano-theme)
(nano-theme)
(require 'nano-modeline)
;(require 'nano-writer)
;;(nano-theme)
;;
  #+end_src

  Obsolete function due to nano-toggle-face
  #+begin_src emacs-lisp :tangle no

(defun nano-change-theme-dark ()
  (interactive)
  (progn
  (nano-theme-set-dark)
  (nano-faces)
  (nano-theme)))

(defun nano-change-theme-light ()
  (interactive)
  (progn
  (nano-theme-set-light)
  (nano-faces)
  (nano-theme)))

(defun nano-change-theme ()
  (interactive)
  (if nano-theme-light-var (nano-change-theme-dark) (nano-change-theme-light))
  (setq nano-theme-light-var (not nano-theme-light-var)))
  #+end_src

  I always want this, regardless of whether I am uisng nano or not.

  #+begin_src emacs-lisp :tangle yes
(setq default-frame-alist
      (append (list
	       ;; '(font . "Roboto Mono Emacs Regular:size=14")
	       '(min-height . 1)  '(height     . 45)
	       '(min-width  . 1) '(width      . 81)
               '(vertical-scroll-bars . nil)
               '(internal-border-width . 40)
               '(left-fringe    . 0)
               '(right-fringe   . 0)
               '(tool-bar-lines . 0)
               '(menu-bar-lines . 0))))



;  (setq centaur-tabs-style "wave")
;  (setq centaur-tabs-set-bar 'under)
;; Note: If you're not using Spacmeacs, in order for the underline to display
;; correctly you must add the following line:
;(setq x-underline-at-descent-line t)


;;
;;; Packages
  #+end_src
*** Doom
   I'm either using nano or doom-theme, this is the latter
   #+begin_src emacs-lisp :tangle yes
(setq doom-theme 'doom-flatwhite)
   #+end_src

To set the fringes how i want them, i.e, in the opposite color of the background.
#+begin_src emacs-lisp :tangle yes
(add-hook! 'solaire-mode-hook
  ;(set-face-attribute 'solaire-fringe-face nil :background (face-background 'solaire-hl-line-face))
  (set-face-attribute 'fringe nil :background (face-background 'solaire-default-face))
  )
#+end_src

** Fonts

It's nice to have both mono and proportional fonts in org-mode, but mostly proportional, as we are writing.
#+begin_src emacs-lisp :tangle yes
(use-package! mixed-pitch
  :hook (org-mode . mixed-pitch-mode)
  :config
  (setq mixed-pitch-face 'variable-pitch))
#+end_src

There's not a lot of good fonts I've noticed. Fira code is the one I keep coming back to.
#+begin_src emacs-lisp :tangle yes
(setq doom-font (font-spec :family "FiraCode Nerd Font" :size 15 :weight 'light)
       doom-variable-pitch-font (font-spec :family "Roboto" :style "Regular" :size 12 :weight 'regular))

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You an either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
#+end_src

** Modeline
#+begin_src emacs-lisp :tangle no
(defvar +modeline--old-bar-height nil)
;;;###autoload
(defun +modeline-resize-for-font-h ()
  "Adjust the modeline's height when the font size is changed by
`doom/increase-font-size' or `doom/decrease-font-size'.
Meant for `doom-change-font-size-hook'."
  (unless +modeline--old-bar-height
    (setq +modeline--old-bar-height doom-modeline-height))
  (let ((default-height +modeline--old-bar-height)
        (scale (or (frame-parameter nil 'font-scale) 0)))
    (setq doom-modeline-height
          (if (> scale 0)
              (+ default-height (* scale doom-font-increment))
            default-height))))

;;;###autoload
(defun +modeline-update-env-in-all-windows-h (&rest _)
  "Update version strings in all buffers."
  (dolist (window (window-list))
    (with-selected-window window
      (when (fboundp 'doom-modeline-update-env)
        (doom-modeline-update-env))
      (force-mode-line-update))))

;;;###autoload
(defun +modeline-clear-env-in-all-windows-h (&rest _)
  "Blank out version strings in all buffers."
  (unless (featurep! +light)
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (setq doom-modeline-env--version
              (bound-and-true-p doom-modeline-load-string)))))
  (force-mode-line-update t))

(use-package! doom-modeline
  :hook (after-init . doom-modeline-mode)
  :hook (doom-modeline-mode . size-indication-mode) ; filesize in modeline
  :hook (doom-modeline-mode . column-number-mode)   ; cursor column in modeline
  :init
  (unless after-init-time
    ;; prevent flash of unstyled modeline at startup
    (setq-default mode-line-format nil))
  ;; We display project info in the modeline ourselves
  (setq projectile-dynamic-mode-line nil)
  ;; Set these early so they don't trigger variable watchers
  (setq doom-modeline-bar-width 3
        doom-modeline-github nil
        doom-modeline-mu4e nil
        doom-modeline-persp-name nil
        doom-modeline-minor-modes nil
        doom-modeline-major-mode-icon nil
        doom-modeline-buffer-file-name-style 'relative-from-project
        ;; Only show file encoding if it's non-UTF-8 and different line endings
        ;; than the current OSes preference
        doom-modeline-buffer-encoding 'nondefault
        doom-modeline-default-eol-type
        (cond (IS-MAC 2)
              (IS-WINDOWS 1)
              (0)))

  ;; Fix modeline icons in daemon-spawned graphical frames. We have our own
  ;; mechanism for disabling all-the-icons, so we don't need doom-modeline to do
  ;; it for us. However, this may cause unwanted padding in the modeline in
  ;; daemon-spawned terminal frames. If it bothers you, you may prefer
  ;; `doom-modeline-icon' set to `nil'.
  (when (daemonp)
    (setq doom-modeline-icon t))
  :config
  ;; HACK Fix #4102 due to empty all-the-icons return value (caused by
  ;;      `doom--disable-all-the-icons-in-tty-a' advice) in tty daemon frames.
  (defadvice! +modeline-disable-icon-in-daemon-a (orig-fn &rest args)
    :around #'doom-modeline-propertize-icon
    (when (display-graphic-p)
      (apply orig-fn args)))

  ;; Fix an issue where these two variables aren't defined in TTY Emacs on MacOS
  (defvar mouse-wheel-down-event nil)
  (defvar mouse-wheel-up-event nil)

  (add-hook 'after-setting-font-hook #'+modeline-resize-for-font-h)
  (add-hook 'doom-load-theme-hook #'doom-modeline-refresh-bars)

  (add-hook '+doom-dashboard-mode-hook #'doom-modeline-set-project-modeline)

  (add-hook! 'magit-mode-hook
    (defun +modeline-hide-in-non-status-buffer-h ()
      "Show minimal modeline in magit-status buffer, no modeline elsewhere."
      (if (eq major-mode 'magit-status-mode)
          (doom-modeline-set-vcs-modeline)
        (hide-mode-line-mode))))

  ;; Some functions modify the buffer, causing the modeline to show a false
  ;; modified state, so force them to behave.
  (defadvice! +modeline--inhibit-modification-hooks-a (orig-fn &rest args)
    :around #'ws-butler-after-save
    (with-silent-modifications (apply orig-fn args))))
#+end_src

#+begin_src emacs-lisp :tangle no
(defun doom-modeline--set-char-widths (alist)
  "Set correct widths of icons characters in ALIST."
  (while (char-table-parent char-width-table)
    (setq char-width-table (char-table-parent char-width-table)))
  (dolist (pair alist)
    (let ((width 1)
          (chars (cdr pair))
          (table (make-char-table nil)))
      (dolist (char chars)
        (set-char-table-range table char width))
      (optimize-char-table table)
      (set-char-table-parent table char-width-table)
      (setq char-width-table table))))

#+end_src
*** Doom-modeline settings

#+begin_src elisp :tangle yes
(after! doom-modeline
  (setq doom-modeline-enable-word-count t
        doom-modeline-header-line nil
        ;doom-modeline-hud nil
        doom-themes-padded-modeline t
        doom-flatwhite-brighter-modeline nil
        doom-plain-brighter-modeline nil))
(add-hook! 'doom-modeline-mode-hook
           (progn
  (set-face-attribute 'header-line nil
                      :background (face-background 'mode-line)
                      :foreground (face-foreground 'mode-line))
  ))
#+end_src

Trying to make my own thing work
#+begin_src emacs-lisp :tangle yes
(after! doom-modeline
  (doom-modeline-def-modeline 'main
    '(bar matches buffer-info vcs word-count)
    '(buffer-position misc-info major-mode)))
#+end_src

*** Mlscroll

    Very cool indicator of where you are in the buffer. Works not that well with `doom-modeline` though.

#+begin_src emacs-lisp :tangle no
(use-package! mlscroll
  :preface
  ;(setq mlscroll-mode-line-font-width 9)
  :init
  (message "Init mode line %s" 'mode-line)
  (setq mlscroll-right-align nil)
  (add-to-list 'mode-line-misc-info '(:eval (mlscroll-mode-line)) 'append)
  (setq mlscroll-width-chars 15)
  (setq mlscroll-border 6)
  (setq mlscroll-in-color "#555555")
  ;(setq mlscroll-mode-line-font-width 9)
  :config
  (mlscroll-mode 1)
  ;(setq mlscroll-mode-line-font-with 9)
  )
#+end_src



** Startup

   #+begin_src emacs-lisp :tangle no
(use-package! dashboard
  :init
  (dashboard-setup-startup-hook)
  ;(setq initial-buffer-choice
  ;      (lambda () (get-buffer "*dashboard*")))
  :config
  (setq dashboard-center-content t
        dashboard-banner-logo-title "Emacs"
        dashboard-startup-banner 'logo
        dashboard-set-file-icons t
        dashboard-set-heading-icons t
        dashboard-set-init-info t
        dashboard-week-agenda t
        ))
   #+end_src

** Centaur tabs

Love me some tabs, but the doom defaults could be better.
#+begin_src emacs-lisp :tangle yes
(after! centaur-tabs
  (setq centaur-tabs-style "wave"))
#+end_src

** Ivy
The Doom defaults are nice, but I really dislike that  the size of the posframe keeps changing.
Also I want it to be on top and with some margin, which requires some extra config
#+begin_src emacs-lisp :tangle no
(defvar ivy-posframewidth 120)
(setq ivy-posframe-width
  (round (* 0.6 (frame-width))))

;; Please just keep the width fixed
(defun set-ivy-posframe-width ()
  (progn
(setq ivy-posframe-width
  (round (* 0.6 (frame-width))))
(setq      ivy-posframe-parameters
        `((min-width . 90)
          (width . ,ivy-posframe-width)
          (height . ,ivy-height)
          ))))

(defun posframe-poshandler-frame-top-center-margin (info)
  "Posframe's position handler.
Get a position which let posframe stay onto its
parent-frame's top center.  The structure of INFO can
be found in docstring of `posframe-show'."
  (cons (/ (- (plist-get info :parent-frame-width)
              (plist-get info :posframe-width))
           2)
        100))

(defun thomas/ivy-posframe-display-at-frame-top-center (str)
  (ivy-posframe--display str #'posframe-poshandler-frame-top-center-margin))


(use-package! ivy-posframe
  :hook (ivy-mode . ivy-posframe-mode)
  :config
  (add-hook! 'ivy-posframe-hook #'set-ivy-posframe-width)
  (setq ivy-fixed-height-minibuffer nil
        ivy-posframe-display-functions-alist '((t . thomas/ivy-posframe-display-at-frame-top-center))
        ivy-posframe-border-width 2
        ivy-posframe-parameters
        `((min-width . 90)
          (width . ,ivy-posframe-width)
          (min-height . ,ivy-height)
          (height . ,ivy-height)
          ))

  ;; default to posframe display function
  ;(setf (alist-get t ivy-posframe-display-functions-alist)
  ;      #'+ivy-display-at-frame-center-near-bottom-fn)


  ;; posframe doesn't work well with async sources (the posframe will
  ;; occasionally stop responding/redrawing), and causes violent resizing of the
  ;; posframe.
  (dolist (fn '(swiper counsel-rg counsel-grep counsel-git-grep))
    (setf (alist-get fn ivy-posframe-display-functions-alist)
          #'ivy-display-function-fallback))

  (add-hook 'doom-after-reload-hook #'posframe-delete-all))
#+end_src

* Org-Mode customization


Allows you to jump in and out of latex fragments without using `C-c C-x C-l` all the time, beautiful.
#+begin_src emacs-lisp :tangle yes
(use-package! org-fragtog
  :after org
  :hook (org-mode . org-fragtog-mode)
  )

#+end_src

Org-appear for everything else.
#+begin_src emacs-lisp :tangle yes
(use-package! org-appear
  :after org
  :hook (org-mode . org-appear-mode)
  :config (setq
           org-appear-autolinks t
           org-appear-autoentities t
           org-appear-autosubmarkers t ))


#+end_src

Buggy yet beautiful transclusion of org-content from another file in the current buffer. Very cool that this is possible, but I don't use it consistently as the "code" is kind of a bitch to write and gets rid of org-roam links.
#+begin_src emacs-lisp :tangle yes
(use-package! org-transclusion
  :after org-roam
  )
#+end_src

Having zero-width spaces can be very useful /sometimes/​!
#+begin_src emacs-lisp :tangle yes

(map! :map org-mode-map
:nie "C-M-SPC" (cmd! (insert "\u200B")))
#+end_src

** Org-roam
Fantastic package which allows you to backlink etc.

*** v2 baby
#+begin_src emacs-lisp :tangle yes
(setq org-roam-v2-ack t)

(use-package! org-roam
  :after org
  :config
  (setq org-roam-v2-ack t)
  (setq org-roam-mode-sections
        (list #'org-roam-backlinks-insert-section
              #'org-roam-reflinks-insert-section
              #'org-roam-unlinked-references-insert-section))
  (org-roam-setup))
 #+end_src

*** Hotter Buffer
#+begin_src emacs-lisp :tangle yes
(defun org-roam-buffer-setup ()
  "Function to make org-roam-buffer more pretty."
  (progn
    (setq-local olivetti-body-width 44)
    (variable-pitch-mode 1)
    (olivetti-mode 1)
    (centaur-tabs-local-mode -1)

  (set-face-background 'magit-section-highlight (face-background 'default))))

(after! org-roam
(add-hook! 'org-roam-mode-hook #'org-roam-buffer-setup))
#+end_src
*** Org-Roam-UI
My baby

#+begin_src emacs-lisp :tangle yes
(use-package! org-roam-ui
  :after org-roam
  :config
  (setq org-roam-ui-open-on-start nil)
  (setq org-roam-ui-browser-function #'xwidget-webkit-browse-url))
#+end_src


*** Org-roam-capture templates

#+begin_src emacs-lisp :tangle yes
(after! org-roam
    (setq org-roam-capture-templates
          `(("s" "standard" plain "%?"
     :if-new
     (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
      "#+title: ${title}\n#+filetags: \n\n ")
     :unnarrowed t)
        ("d" "definition" plain
         "%?"
         :if-new
         (file+head "${slug}.org" "#+title: ${title}\n#+filetags: definition \n\n* Definition\n\n\n* Examples\n")
         :unnarrowed t)
        ("r" "ref" plain "%?"
           :if-new
           (file+head "${citekey}.org"
           "#+title: ${slug}: ${title}\n
\n#+filetags: reference ${keywords} \n
\n* ${title}\n\n
\n* Summary
\n\n\n* Rough note space\n")
           :unnarrowed t)
          ("p" "person" plain "%?"
           :if-new
           (file+head "${slug}.org" "%^{relation|some guy|family|friend|colleague}p %^{birthday}p %^{address}p
,#+title:${slug}\n#+filetags: :person: \n"
                      :unnarrowed t)))))

#+end_src

*** Server
**** Protocol
#+begin_src emacs-lisp :tangle no

;; Since the org module lazy loads org-protocol (waits until an org URL is
;; detected), we can safely chain `org-roam-protocol' to it.
(use-package! org-roam-protocol
  :after org-protocol)
#+end_src

**** Actual server
#+begin_src emacs-lisp :tangle no

(use-package! org-roam-server
  :after org-roam
  :config
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 8081
        org-roam-server-authenticate nil
        org-roam-server-export-inline-images t
        org-roam-server-serve-files nil
        org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
        org-roam-server-network-poll t
        org-roam-server-network-arrows nil
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60
        org-roam-server-network-label-wrap-length 20
        org-roam-server-network-vis-options "{\"physics\": {\"stabilization\": {\"iterations\": 100}}}"
        ;i;"{\"physics\": {\"enabled\": true, \"barnesHut\":{\"gravitationalConstant\" : -6000, \"avoidOverlap\" : 0.5, \"springLength\" : 200}, \"stabilization\": {\"enabled\": true, \"iterations\": 30}},
        ;;\"edges\": {\"physics\": true, \"hidden\": false, \"smooth\": {\"enabled\": false, \"type\": \"continuous\"}}}"
        org-roam-server-cite-edge-dashes nil
        org-roam-server-extra-cite-edge-options (list (cons 'width 3))
        ))
#+end_src

Org-roam server does not really work well with with `smart-parens` for some reason, this fixes that.
#+begin_src emacs-lisp :tangle no
(defun org-roam-server-open ()
    "Ensure the server is active, then open the roam graph."
    (interactive)
    (smartparens-global-mode -1)
    (org-roam-server-mode 1)
    (browse-url-xdg-open (format "http://localhost:%d" org-roam-server-port))
    (smartparens-global-mode 1))

;; automatically enable server-mode
(after! org-roam
  (smartparens-global-mode -1)
  (org-roam-server-mode)
  (smartparens-global-mode 1))
#+end_src

*** Citations
#+begin_src emacs-lisp :tangle yes
(use-package! org-ref
    ;:after org-roam
    :config
    (setq
         org-ref-completion-library 'org-ref-ivy-cite
         org-ref-get-pdf-filename-function 'org-ref-get-pdf-filename-helm-bibtex
         org-ref-default-bibliography (list "/Users/thomas/OneDrive/org-roam/bib/Library.bib")
         org-ref-bibliography-notes "/Users/thomas/OneDrive/org-roam/bibnotes.org"
         org-ref-note-title-format "* %y - %t\n :PROPERTIES:\n  :Custom_ID: %k\n  :NOTER_DOCUMENT: %F\n :ROAM_KEY: cite:%k\n  :AUTHOR: %9a\n  :JOURNAL: %j\n  :YEAR: %y\n  :VOLUME: %v\n  :PAGES: %p\n  :DOI: %D\n  :URL: %U\n :END:\n\n"
         org-ref-notes-directory "/Users/thomas/OneDrive/org-roam/"
         org-ref-notes-function 'orb-edit-notes
    ))

(after! org-ref
(setq
 bibtex-completion-notes-path "/Users/thomas/OneDrive/org-roam/"
 bibtex-completion-bibliography "/Users/thomas/OneDrive/org-roam/bib/Library.bib"
 bibtex-completion-pdf-field "file"
 bibtex-completion-notes-template-multiple-files
 (concat
  "#+TITLE: ${title}\n"
  "#+ROAM_KEY: cite:${=key=}\n"
  "* TODO Notes\n"
  ":PROPERTIES:\n"
  ":Custom_ID: ${=key=}\n"
  ":NOTER_DOCUMENT: %(orb-process-file-field \"${=key=}\")\n"
  ":AUTHOR: ${author-abbrev}\n"
  ":JOURNAL: ${journaltitle}\n"
  ":DATE: ${date}\n"
  ":YEAR: ${year}\n"
  ":DOI: ${doi}\n"
  ":URL: ${url}\n"
  ":END:\n\n"
  )
 )
)

#+end_src

Company-org-roam seemed like a good idea, but I never use it.

#+begin_src emacs-lisp :tangle no
        (use-package! company-org-roam
  :after org-roam
  :config
  (set-company-backend! 'org-mode '(company-org-roam company-yasnippet company-dabbrev)))
#+end_src

ORB
#+begin_src emacs-lisp :tangle yes

(use-package! org-roam-bibtex
  :after org-roam
  :hook (org-mode . org-roam-bibtex-mode)
  :config
  (require 'org-ref)
  (setq orb-preformat-keywords
   '("citekey" "title" "url" "file" "author-or-editor" "keywords" "pdf" "doi" "author" "tags" "year" "author-bbrev")))
;)
#+end_src

** To do things with pdfs with

   Don't really use this anymore since zotero got a pdf reader
#+begin_src emacs-lisp :tangle no
   (use-package! org-noter
  :after (:any org pdf-view)
  :config
  (setq
   ;; The WM can handle splits
   ;;org-noter-notes-window-location 'other-frame
   ;; Please stop opening frames
   ;;org-noter-always-create-frame nil
   ;; I want to see the whole file
   org-noter-hide-other nil
   ;; Everything is relative to the rclone mega
   org-noter-notes-search-path "/Users/thomas/OneDrive/org-roam"
   )
  )


(use-package! org-pdftools
  :hook (org-load . org-pdftools-setup-link))
(use-package! org-noter-pdftools
  :after org-noter
  :config
  (with-eval-after-load 'pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))


#+end_src

nroam puts the org-roam buffer on the bottom, much more natural and less obstrustive, but not does cause some problems.
#+begin_src emacs-lisp :tangle no
        (use-package! nroam
  :after org-roam
  :config
  (add-hook 'org-roam-mode-hook  #'nroam-setup-maybe)
)


#+end_src

*** Org-ol

    Outliners on the side, neat.

#+begin_src emacs-lisp :tangle yes
(use-package! org-ol-tree
  :after org
  :commands org-ol-tree
  :hook (org-ol-tree-mode . visual-line-mode)
  :config
  (setq org-ol-tree-ui-window-auto-resize nil
        org-ol-tree-ui-window-max-width 0.3
        org-ol-tree-ui-window-position 'left))
(map! :map org-mode-map
      :after org
      :localleader
      :desc "Outline" "O" #'org-ol-tree)
#+end_src
** Hooks

*** Hook to get rid of stars

You know what I hate? Organized lists.
No but when I'm writing I don't want org's usual indentation and stars and all that bullshit, I want it to look like a wordprocessor, so no stars!

#+begin_src emacs-lisp :tangle yes
(defun org-mode-remove-stars ()
  (font-lock-add-keywords
   nil
   '(("^\\*+ "
      (0
       (prog1 nil
         (put-text-property (match-beginning 0) (match-end 0)
                            'invisible t)))))))

(add-hook! 'org-mode-hook #'org-mode-remove-stars)
#+end_src

*** Yeah I don't know where to put this
#+begin_src emacs-lisp :tangle yes
  ;; hide title / author ... keywords

;;; Ugly org hooks
(defun nicer-org ()
  (progn
  (+org-pretty-mode 1)
  (mixed-pitch-mode 1)
  (hl-line-mode -1)
  (display-line-numbers-mode -1)
  (olivetti-mode 1)
  ;(org-num-mode 1)
  (org-superstar-mode -1)
  (org-indent-mode -1)
  ))

(add-hook! 'org-mode-hook  #'nicer-org)

#+end_src

*** Org variables

fuckin latex
For some reason it can't find the dang latex executable, so we're just adding the path to it by hand like some sort of caveman
#+begin_src emacs-lisp :tangle yes
(setq org-preview-latex-process-alist
  '((dvipng
     :programs ("/Library/TeX/texbin/latex" "/Library/TeX/texbin/dvipng")
     :description "dvi > png"
     :message "you need to install the programs: latex and dvipng."
     :image-input-type "dvi"
     :image-output-type "png"
     :image-size-adjust (1.0 . 1.0)
     :latex-compiler ("/Library/TeX/texbin/latex -interaction nonstopmode -output-directory %o %f")
     :image-converter ("/Library/TeX/texbin/dvipng -D %D -T tight -bg Transparent -o %O %f"))
    (dvisvgm
     :programs ("/Library/TeX/texbin/latex" "/Library/TeX/texbin/dvisvgm")
     :description "dvi > svg"
     :message "you need to install the programs: latex and dvisvgm."
     :image-input-type "dvi"
     :image-output-type "svg"
     :image-size-adjust (1.7 . 1.5)
     :latex-compiler ("/Library/TeX/texbin/latex -interaction nonstopmode -output-directory %o %f")
     :image-converter ("/Library/TeX/texbin/dvisvgm %f -n -b min -c %S -o %O"))
    (imagemagick
     :programs ("latex" "convert")
     :description "pdf > png"
     :message "you need to install the programs: latex and imagemagick."
     :image-input-type "pdf"
     :image-output-type "png"
     :image-size-adjust (1.0 . 1.0)
     :latex-compiler ("pdflatex -interaction nonstopmode -output-directory %o %f")
     :image-converter
     ("convert -density %D -trim -antialias %f -quality 100 %O"))))
#+end_src
#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-startup-with-latex-preview 1 ;always preview latex
        org-latex-create-formula-image-program 'dvipng
        LaTeX-command "/Library/TeX/texbin/latex"
        latex-run-command "/Library/TeX/texbin/latex"
        org-startup-with-inline-images 1 ;always preview images
        ;org-hide-leading-stars 1
        org-startup-indented nil         ; don't indent
  ;      org-startup-folded nil
        org-hidden-keywords '(filetags title author date startup roam_tags)
        org-pretty-entities 1            ; show unicode characters
        org-num-max-level 3              ; no 1.1.1.2
        org-indirect-buffer-display 'other-window
        line-spacing 3 ; let me B R E A T H E
        )
  (setenv "PATH" (concat (getenv "PATH") ":/Library/TeX/texbin")))
#+end_src

**** Better indirect buffers
Sometimes I want to move a tree to an indirect buffer, but sometimes I want to put it in another window, sometimes the same one, and sometimes to another frame. By default there are no functions for this but are controlled by ~org-indirect-buffer-display~. This is a hacky way of achieving this
#+begin_src emacs-lisp :tangle yes
(defun +org-tree-to-indirect-buffer-options (option)
    (let* ((old-value org-indirect-buffer-display))
          (progn
            (setq org-indirect-buffer-display option)
          (org-tree-to-indirect-buffer)
          (setq org-indirect-buffer-display old-value))))

(defun +org-tree-to-indirect-other-window ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'other-window))

(defun +org-tree-to-indirect-current-window ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'current-window))

(defun +org-tree-to-indirect-dedicated-frame ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'dedicated-frame))
#+end_src
*** Custom faces

A lil bigger. No a lil smaller. Peeerrrfect.
#+begin_src emacs-lisp :tangle yes
(after! org
(custom-set-faces!
  '((org-block) :background nil)
  )
  (defface redd
    '((((class color) (min-colors 88) (background light))
      :foreground "red"))
    "Red."
    :group 'basic-faces)
  (custom-set-faces!
    ;'(org-document-title :height 1.6 :weight bold)
    '(org-level-1 :height 1.3 :weight extrabold :slant normal)
    '(org-level-2 :height 1.2 :weight bold :slant normal)
    '(org-level-3 :height 1.1 :weight regular :slant normal)
    ;'(org-document-info  :inherit 'nano-face-faded)
    '(org-document-title   ;:foreground ,(doom-color 'black)
                           :family "Roboto"
                           :height 250
                           :weight medium)))
#+end_src
*** Emphasis faces

I want to be able to do some kind of custom highlighting, so = becomes =red=.
#+begin_src emacs-lisp :tangle yes
(after! org
(setq org-emphasis-alist
        '(("*" (bold))
          ("/" italic)
          ("_" underline)
          ("=" redd)
          ("~" code)
          ("+" (:strike-through t)))))
#+end_src

Ideally I would be able to add my own custom bullshit in here, but I don't know how to do that.

*** Ligatures

    Yns  make them pretty
#+begin_src emacs-lisp :tangle yes
        (after! org
(setq org-ellipsis " ▾ ")
  (appendq! +ligatures-extra-symbols
          `(:checkbox      "☐"
            :pending       "◼"
            :checkedbox    "☑"
            :list_property "∷"
            :em_dash       "—"
            :ellipses      "…"
            :arrow_right   "→"
            :arrow_left    "←"
            :title         nil
            :subtitle      "𝙩"
            :author        "𝘼"
            :date          "𝘿"
            :property      ""
            :options       "⌥"
            :startup       "⏻"
            :macro         "𝓜"
            :html_head     "🅷"
            :html          "🅗"
            :latex_class   "🄻"
            :latex_header  "🅻"
            :beamer_header "🅑"
            :latex         "🅛"
            :attr_latex    "🄛"
            :attr_html     "🄗"
            :attr_org      "⒪"
            :begin_quote   "❝"
            :end_quote     "❞"
            :caption       "☰"
            :header        "›"
            :results       "🠶"
            :begin_export  "⏩"
            :end_export    "⏪"
            :properties    ""
            :end           "∎"
            :priority_a   ,(propertize "⚑" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "⬆" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "■" 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "⬇" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "❓" 'face 'all-the-icons-blue)
            :roam_tags nil
            :filetags nil))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]"
  :roam_tags     "#+roam_tags:"
  :filetags      "#+filetags:")
(plist-put +ligatures-extra-symbols :name "⁍")
)

(with-eval-after-load 'org
  (plist-put org-format-latex-options :background 'default))

#+end_src

** Getting Things Done

   Oh yeah this is definitely working for me I've definitely changed as a person.
*** GTD package
    It's pretty good, but it doesn't do my organizing for me sadly.
  #+begin_src emacs-lisp :tangle yes
(use-package! org-gtd
  :after org
  :config
  ;; where org-gtd will put its files. This value is also the default one.
  (setq org-gtd-directory "~/OneDrive/org-roam/")
  ;; package: https://github.com/Malabarba/org-agenda-property
  ;; this is so you can see who an item was delegated to in the agenda
  (setq org-agenda-property-list '("DELEGATED_TO"))
  ;; I think this makes the agenda easier to read
  (setq org-agenda-property-position 'next-line)
  ;; package: https://www.nongnu.org/org-edna-el/
  ;; org-edna is used to make sure that when a project task gets DONE,
  ;; the next TODO is automatically changed to NEXT.
  (setq org-edna-use-inheritance t)
  (org-edna-load)
  :bind
  (("C-c d c" . org-gtd-capture) ;; add item to inbox
  ("C-c d a" . org-agenda-list) ;; see what's on your plate today
  ("C-c d p" . org-gtd-process-inbox) ;; process entire inbox
  ("C-c d n" . org-gtd-show-all-next) ;; see all NEXT items
  ("C-c d s" . org-gtd-show-stuck-projects)) ;; see projects that don't have a NEXT item
  :init
  (bind-key "C-c c" 'org-gtd-clarify-finalize)) ;; the keybinding to hit when you're done editing an item in the processing phase
#+end_src

*** Set agenda files
Because you can't trust ~custom.el~
#+begin_src emacs-lisp :tangle yes

(setq org-agenda-files '("~/OneDrive/org-roam/inbox" "~/OneDrive/org-roam/actionable.org"
                         "~/OneDrive/org-roam/agenda.org" "~/OneDrive/org-roam/incubate.org"
                         "~/OneDrive/org-roam/openquestions.org"))
#+end_src

*** Org capture Templates

Set some capture templates, which I rarely use tbrqhwy
#+begin_src emacs-lisp :tangle yes
(after! org
(setq org-capture-templates `(("i" "Inbox"
                                 entry (file "~/OneDrive/org-roam/inbox.org")
                                 "* %?\n%U\n\n  %i"
                                 :kill-buffer t)
                                ("l" "Todo with link"
                                 entry (file "~/OneDrive/org-rom/inbox.org")
                                 "* %?\n%U\n\n  %i\n  %a"
                                 :kill-buffer t)
                                ("m" "Meeting"
                                 entry (file+headline "/Users/thomas/OneDrive/org-roam/agenda.org" "Future")
                                ,(concat "* TODO %? :meeting:\n" "<%<%Y-%m-%d %a %H:00>>"))
                                ("o" "Open Question Thesis"
                                 entry (file+headline "~/OneDrive/org-roam/openquestions.org" "Questions")
                                 "* OPEN %? \n %U\n")))
(set-face-attribute 'org-headline-done nil :strike-through t)
)
#+end_src
*** Org-super agenda

Why yes, I also copied this one example from the ~org-super-agenda~ github, how could you tell?

This does not work nearly as well as I would like it to, like, utility wise. Way too long, way too much information, bubububuh. I want more of a calendar than an agenda I think.
 #+begin_src emacs-lisp :tangle yes
(use-package! org-super-agenda
  :hook (org-agenda-mode . org-super-agenda-mode)
)


  (setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-include-diary t
      org-agenda-block-separator nil
      org-agenda-compact-blocks t
      org-agenda-start-with-log-mode t
      org-agenda-start-day nil)
(setq org-agenda-custom-commands
      '(("d" "Get Things DONE"
         ((agenda "" ((org-agenda-span 1)
                      (org-super-agenda-groups
                       '((:name "Today"
                                :time-grid t
                                :date nil
                                :todo "TODAY"
                                :scheduled nil
                                :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:discard (:todo "TODO"))
                          (:name "Important"
                                 :tag "Important"
                                 :priority "A"
                                 :order 1)
                          (:name "Due Today"
                                 :deadline today
                                 :order 2)
                          (:name "Due Soon"
                                 :deadline future
                                 :order 8)
                          (:name "Overdue"
                                 :deadline past
                                 :order 7)
                          (:name "Thesis"
                                 :tag "thesis"
                                 :order 10)
                          (:name "ESN"
                                 :tag "esn"
                                 :order 12)
                          (:name "JOTE"
                                 :tag "jote"
                                 :order 13)
                          (:name "Emacs"
                                 :tag "emacs"
                                 :order 14)
                          (:name "Home"
                                 :tag "home"
                                 :order 30)
                          (:name "Waiting"
                                 :todo "WAITING"
                                 :order 20)
                          (:name "Notes"
                                 :tag "notes"
                                 :order 20)
                          ;(:name "Open Questions"
                          ;       :todo "OPEN"
                          ;       :order 3)
                          (:name "trivial"
                                 :priority<= "C"
                                 :tag ("Trivial" "Unimportant")
                                 :todo ("SOMEDAY" )
                                 :order 90)
                          (:discard (:tag ("Chore" "Routine" "Daily")))))))))))

 #+end_src

*** Notifications

I want notifications to work so bad but it just isn't working :(
Seems like ~alert~ is not working, should fix that at some point.
#+begin_src emacs-lisp :tangle no
(use-package! org-notifications
  :init (org-notifications-start) )
#+end_src

** Nice writing environment for big babies
Nice big border with the color of the fringe
#+begin_src emacs-lisp :tangle yes
(setq default-frame-alist
      (append (list
	       ;; '(font . "Roboto Mono Emacs Regular:size=14")
	       '(min-height . 1)  '(height     . 45)
	       '(min-width  . 1) '(width      . 81)
               '(vertical-scroll-bars . nil)
               '(internal-border-width . 30)
               '(left-fringe    . 0)
               '(right-fringe   . 0)
               '(tool-bar-lines . 0)
               '(menu-bar-lines . 0))))

(add-hook! 'solaire-mode-hook (set-face-background 'internal-border (face-background 'fringe)))

(set-frame-parameter nil 'internal-border-width 60)
#+end_src

*** Paper-like header/mode-line
Lil' minor mode which gives you a nice distraction free header and footer. At the moment its automatically enabled in org-mode, but I would like it to only be enabled in "writing" buffers, not sure how to implement that yet though.

#+begin_src emacs-lisp :tangle yes
(defvar writing-header--default-format header-line-format
  "Storage for the default `mode-line-format'.
So it can be restored when 'writer-header-line-mode' is disabled.")

(defvar writing-modeline--default-format mode-line-format)

(define-minor-mode writing-header-line-mode
  "Adds a bar with the same color as the fringe as the header-line.
Imitates the look of wordprocessors a bit."
  :init-value nil
  :global nil
  (if writing-header-line-mode
      (progn
      (setq header-line-format
            (concat
             (propertize " " 'display (list 'space :width 'left-fringe) 'face 'fringe)
             (propertize " " 'display (list 'space :width 'left-margin) 'face (list (list :height 400) 'default))
             (propertize " " 'display (list 'space :width 'text) 'face (list (list :height 400) 'default))
             ;(propertize (format " %dW" (count-words (point-min) (point-max))) 'face 'default)
             (propertize " " 'display (list 'space :width 'left-margin) 'face (list (list :height 400) 'default))
    ;;(propertize (format " %dW" (count-words (point-min) (point-max))) 'face 'fringe)
   ;; '("" mode-line-misc-info)
             (propertize " " 'display (list 'space :width 'left-fringe) 'face 'fringe))) ;
        (setq mode-line-format header-line-format))
    (setq header-line-format writing-header--default-format
          mode-line-format writing-modeline--default-format)))
#+end_src

**** Experiment with Rougier's double modeline

#+begin_src emacs-lisp :tangle no
;; -------------------------------------------------------------------
;; A proof of concept for a multi header or mode line
;;
;; Multi line header or mode line is made possible by generating an
;; SVG image made of two small lines of text. It is certainly memory
;; hungry but it seems to be fast enough to display line/column while
;; typing text. It can probably be extended in a number of ways.
;;
;; Feel free to modify it for your own needs.
;; -------------------------------------------------------------------
(require 'svg)

(defun tag (line-1 font-size-1 font-family-1 foreground-1
            line-2 font-size-2 font-family-2 foreground-2
            left)
  (let* ((font-size-1   (or font-size-1 14))
         (char-width-1  (* font-size-1 0.6))
         (char-height-1 (+ font-size-1 0.0))
         (width-1       (* char-width-1 20))
         (height-1      (+ (* char-height-1 2) 1))

         (font-size-2   (or font-size-2 14))
         (char-width-2  (* font-size-2 0.6))
         (char-height-2 (+ font-size-2 0.0))
         (width-2       (* char-width-2 20))
         (height-2      (+ (* char-height-2 2) 1))

         (width         (max width-1 width-2))
         (height        (max height-1 height-2))

         (x1 (if left 0 (- width (* char-width-1 (+ (length line-1) .0)))))
         (x2 (if left 0 (- width (* char-width-2 (+ (length line-2) .0)))))
         (y1 char-height-1)
         (y2 (+ (* char-height-2 2) 1))
         (svg (svg-create width height)))
    (svg-text svg line-1
              :font-family font-family-1
              :font-size font-size-1 :fill foreground-1
              :x x1 :y y1)

    (svg-text svg line-2
              :font-family font-family-2
              :font-size font-size-2 :fill foreground-2
              :x x2 :y y2)
    svg))

(define-key mode-line-major-mode-keymap [header-line]
  (lookup-key mode-line-major-mode-keymap [mode-line]))

(defun mode-line-render (left right)
  (let* ((available-width (- (window-width) (length left))))
    (format (format "%%s %%%ds" available-width) left right)))

(setq header-line-format
     '((:eval
       (mode-line-render
        (format-mode-line
          (propertize (make-string 20 ?\ )
                      'display (svg-image
                        (tag (format-mode-line "%m") 12 "Roboto Mono Light" "#00008b"
                             (format-mode-line "%b") 14 "Roboto Mono"       "black"
                             t) :ascent 100)))
        (format-mode-line
          (propertize (make-string 18 ?\ )
                      'display (svg-image
                        (tag (format-mode-line "GNU Emacs 26.3  ") 12 "Roboto Mono Light" "#00008b"
                             (format-mode-line "%4l:%2c") 12 "Roboto Mono Light" "#999999"
                             nil) :ascent 100)))))))
#+end_src


**** My much better version
#+begin_src emacs-lisp :tangle yes
(defcustom double-modeline-margin-inner-height 60
  "inner"
  :type 'integer)
(defcustom double-modeline-margin-outer-height 10
  "outer"
  :type 'integer)
#+end_src
#+begin_src emacs-lisp :tangle yes
(after! org
        (require 'svg))
(defun make-svg-rectangle (width height-1 bg-1 height-2 bg-2)
  (let* ((svg (svg-create width (+ height-1 height-2))))
    (svg-rectangle svg 0 0 width height-1 :fill-color bg-1)
    (svg-rectangle svg 0 height-1 width height-2 :fill-color bg-2)
    svg))

(defun make-svg-rectangles (width height-1 bg-1 &rest other)
  (let* ((temptt 0)
         (height-temp height-1)
         (svg (svg-create width
                           (+ height-1
                             (dotimes
                                (i (/ (length other) 2) temptt)
                                         (setq temptt
                                               (+
                                          (nth (* i 2) other)
                                          temptt)))))))
    (svg-rectangle svg 0 0 width height-1 :fill-color bg-1)
    (when other
      (dotimes (i (/ (length other) 2))
    (svg-rectangle svg 0
                   (if (eq i 0) height-1
                     (setq-local height-temp
                                 (+ height-temp
                                    (nth (* (- i 2) 2) other))))
                   width
                   (nth (* i 2) other)
                   :fill-color (nth (+ (* i 2) 1) other))))
    svg))

(defun mode-line-compose (height-1 bg-1 height-2 bg-2
                                   header)
  (let* ((fringe-width (car (window-fringes nil)))
         (body-width (window-body-width nil t))
         (margin-width (* (frame-char-width)
                        (+ (car (window-margins))
                          (cdr (window-margins))))))
    (concat
  (format-mode-line
   (propertize " " 'display (svg-image
    (make-svg-rectangle fringe-width height-1
      bg-1 height-2 bg-1))))
  (format-mode-line
   (propertize " " 'display (svg-image
                            (if header
                             (make-svg-rectangle
                              (+ margin-width body-width)
                        height-1 bg-1 height-2 bg-2)
                             (make-svg-rectangle
                              (+ margin-width body-width)
                        height-2 bg-2 height-1 bg-1)))))
  (format-mode-line
   (propertize " " 'display (svg-image
    (make-svg-rectangle fringe-width height-1
      bg-1 height-2 bg-1)))))))

(defvar double-modeline--default-header-format header-line-format
  "Storage for the default `mode-line-format'.
So it can be restored when 'writer-header-line-mode' is disabled.")

(defvar double-modeline--default-modeline-format mode-line-format)

(define-minor-mode double-header-line-mode
  "Adds a bar with the same color as the fringe as the header-line.
Imitates the look of wordprocessors a bit."
  :init-value nil
  :global nil
  (if double-header-line-mode
      (progn
(set-face-attribute 'mode-line nil :box nil)
(set-face-attribute 'header-line nil :box nil)
(set-face-attribute 'mode-line-inactive nil :box nil)
        (setq header-line-format '((:eval (mode-line-compose
                                   double-modeline-margin-outer-height
                                   (face-background 'fringe)
                                   double-modeline-margin-inner-height
                                   (face-background 'default)
                                   t
                                   ))))
        (setq mode-line-format '((:eval (mode-line-compose
                                   double-modeline-margin-outer-height
                                   (face-background 'fringe)
                                   double-modeline-margin-inner-height
                                   (face-background 'default)
                                   nil
                                   )))))
    (setq header-line-format 'double-modeline--default-header-format
          mode-line-format 'double-modeline--default-modeline-format)))

(after! olivetti-mode (setq double-modeline-margin-inner-height  (round (* 0.6 (* (frame-char-width) (car (window-margins)))))))
#+end_src
*** Page-break-mode
    #+begin_src emacs-lisp :tangle yes
(use-package! page-break-mode)
    #+end_src
*** KILL obsolete pages break
#+begin_src emacs-lisp :tangle no

 (defun change-page-break ()
   (interactive)
   (font-lock-add-keywords 'org-mode
    `((,page-delimiter
       ;; variable with the regexp (usually "^\f" or "^^L")
        0
        (prog1 nil
          ;(compose-region (match-beginning 0) (match-end 0) "")
          ;(testtest)
   (put-text-property (match-beginning 0) (match-end 0)
               'display (svg-image (make-svg-rectangles
                                    ;; just to be sure
                                    (* 3 (window-body-width nil t))
                                    30 "red" 40 "yellow" 30 "red"))
          ;(put-text-property (match-beginning 0) (match-end 0) 'display (make-svg-rectangle (window-body-width nil t) 40 (face-background 'fringe) 30 (face-background 'default)))
          )) t))))
#+end_src

#+begin_src emacs-lisp :tangle no

 (defun change-page-break ()
   (interactive)
   (font-lock-add-keywords 'org-mode
    `((,page-delimiter
       ;; variable with the regexp (usually "^\f" or "^^L")
        0
        (prog1 nil
          ;(compose-region (match-beginning 0) (match-end 0) "")
          ;(testtest)
          ;(put-text-property (match-beginning 0) (match-end 0) 'display (make-svg-rectangle (window-body-width nil t) 40 (face-background 'fringe) 30 (face-background 'default)))
;; don't display ^L
          (make-line-break (* (frame-char-width) (car (window-margins)))
                           (face-background 'default) 40 (face-background 'fringe))) t))))

(defun make-line-break (h1 bg1 h2 bg2)
         (compose-region (match-beginning 0) (match-end 0) "")
          ;; make an overlay (like in hl-line)
          (let ((pdl (make-overlay (line-beginning-position)                                   (line-beginning-position 2))))
            (overlay-put pdl 'put-image t)
            ;(overlay-put pdl 'after-string
            ;             (propertize "x"
            ;                         'display (list (list 'margin 'left-margin)
            ;                                        (svg-image (make-svg-rectangles (* (frame-char-width) (car (window-margins))) h1 bg1 h2 bg2 h1 bg1 )))))
            (overlay-put pdl 'before-string
                         (concat
                         (propertize "x"
                                     'display (list (list 'margin 'right-margin)
                                                    (svg-image (make-svg-rectangles (* (frame-char-width) (car (window-margins))) h1 bg1 h2 bg2 h1 bg1))))
                         (propertize "x"
                                     'display (list (list 'margin 'left-margin)
                                                    (svg-image (make-svg-rectangles (* (frame-char-width) (car (window-margins))) h1 bg1 h2 bg2 h1 bg1 ))))))
            (overlay-put pdl 'map image-map)
            (overlay-put pdl  'display (svg-image (make-svg-rectangles (- (window-body-width nil t) 0 ) h1 bg1 h2 bg2 h1 bg1)))
            (overlay-put pdl 'modification-hooks
                         ;; these arguments are received from modification-hooks
                         '((lambda (overlay after-p begin end &optional length)
                             (delete-overlay overlay))))
               (overlay-put pdl 'insert-in-front-hooks                         '((lambda (overlay after-p begin end &optional length)
                            (delete-overlay overlay))))))


#+end_src
This should go somewhere else
#+begin_src emacs-lisp :tangle no
(after! org (change-page-break))
#+end_src
#+begin_src emacs-lisp :tangle no
(defun testtest ()
  (interactive)
  (aayyy 30 (face-background 'default) 40 (face-background 'fringe)))

(defun aayyy (h1 bg1 h2 bg2)
  (progn
   ;(concat
   ;(propertize " "
   ;'display '((margin left-margin) "a"))
   ;(propertize " "
    ;           'display '((margin right-margin) "b"))
   (insert-image (svg-image (make-svg-rectangles (* (frame-char-width) (car (window-margins))) h1 bg1 h2 bg2 h1 bg1)) nil 'left-margin)
   (insert-image (svg-image (make-svg-rectangles (* (frame-char-width) (cdr (window-margins))) h1 bg1 h2 bg2 h1 bg1)) nil 'right-margin)
   (insert (propertize " "
               'display (svg-image (make-svg-rectangles (window-body-width nil t) h1 bg1 h2 bg2 h1 bg1))))
        ))
#+end_src

**** Pseudocode to get what i want

This basically sets up the structure for how I want the minor-mode to work. It's not very complicated and there are probably a lot of edge cases, but its rather close to what I want ti

#+begin_src emacs-lisp :tangle no
(defun change-lines-hook ()
  (unless (check-if-we-need-to-change-anything)
  (disable-all-my-overlays)
  (put-overlays)))

;;either
(add-hook! 'after-save-hook 'change-lines-hook)

;;or, much too expensive probably.
(add-hook! 'after-change-functions 'change-lines-hook)
;mwah maybe okay, org-num-verify also does this and it's somewhat complicated. Really depends on how hard it is to change things.

(defun check-if-no-annoying-env ()
;; some regex which determines where we are in basically anything that's not a paragraph, such as a heading, a latex environment, a link , a table, or a src block
;; There's probably a function that already does this
;; This is not super important for environtments since the overlay won't be part of the text, but it do be kind of annoying
;(org-at-table-p)
;(org-at-property-p)
;(org-at-property-drawer-p)
;(org-at-property-block-p)
;(org-at-block-p)
;(org-at-heading-p)
;(org-at-heading-or-item-p)
;(org-at-planning-p)

        ;check whether we are in a paragraph and not a latex section
(and (eq (car  (org--paragraph-at-point) 'headline))
    (not (latex))))

(define-minor-mode auto-page-break-overlay-mode nil
  "Adds out page breaks, neat."
  :global nil
  :group wysiwyg
  (if auto-page-break-overlay-mode
      (setq some-defaults-i-need-to-rememeber)
      (progn
        (run-once)
        (add-hooks)
        ;change-lines
        )
      (progn    ;else
        (remove-my-overlays)
        (remove-hooks)
        ;change-lines
        (setq-default some-defaults-i-need-to-remember)
        ))
        )



#+end_src

Big problem with visual line approach is that you cannot scale past a certain point, only until the margins run out, when it suddenly scaling becomes bigger font size.
I need to make this work with olivetti mode better, or if necessary implement it myself. Don't really want to do that though, would rather rely on olivetti mode.
 #+begin_src emacs-lisp :tangle no
;; custom pagebreakinterval
(defcustom pagebreakinterval 40)

;; getting visual line number pos
(defun get-visual-line-number-pos (number)
  ...
        )
;; putting the overlay there
(defun put-overlays ()
(dotimes (i (/ (count-screen-lines) pagebreakinterval))
  (make-overlay (visual-line-number (* pagebreakinterval i)) ;start
                (same)                                       ;end
                'display (svg-image (rectangle))             ;
                )))

;;
(defun check-if-we-need-to-change-anything ()
  "Check if we need to change anything."
  (dolist (list-of-overlays overlay)
    (if (eq (position overlay) (* pagebreakinterval i)) t
      (add-to-list 'overlays-to-change (overlay . new-pos)))))

;; some way of making sure that stays like it should
 #+end_src
Another way of keeping track of position would be keeping track of the number of charachters and setting, somewhat intelligently, a "characters of a certain size per page".
    - Pros
      + Don't care about changing lines
      + Finding nth carachter is easier
    - Cons
      + Can happen in the middle of a visual line (would be on me to compute that). This makes inserting the page-break even trickier
      + Possibly more computation heavy, but probably not, the other thing is already very heavy

#+begin_src emacs-lisp :tangle no
;;similar as above, only the (check-if-we-need-to-change-anything)
;; and (put-overlays) need to change
(defcustom number-of-charchters-per-page 2500
  "Page is like 500 words, word has 5 characters by default, badabing badoom.")

(defun put-overlays-chars ()
  (dotimes (i (round (/ (char-count) number-of-characters-per-page)))
    (if (check-if-no-annoying-env)
        (make-overlay (* number-of-charachters-per-page i)
                      (same)
                      'display etc)
      (progn   ;else
        (make-overlay (+ (* number-of-charachters-per-page i) (check-closest-distance-to-safety)) ;;maybe do it anyway if it's too far
                      etc
                      )
        )
)))
#+end_src

ANSWER: I should use both! Count characters, but also lines: if there are too many lines, pagebreak, if there are too many characters, page break as well! Maybe just use the lines then anyway.

**** Creating some cohesion between margins, line-numbers and font-size

     One of the big problems i need to solve (or opitons i need to provide) is whether zooming=zooming or zooming=scaling, i.e. does it just change the visual appearance of everything or does it increase the font size?
     I think the best would be if that were two options, and by default it would do it badly like you would expect, and then I provide a new command which keeps everything nice.

     The main problem now is that the margins do not scale at all when zooming. This is probably something mr olivetti can fix, but I should take it into account nonetheless.

**** Remembering pages

    I should just create a list with pages.
Either with line or character positions. I can update this instead of the page immediately, should save some trouble.
    #+begin_src emacs-lisp :tangle no
(setq page-list (0))
    #+end_src

**** Numbering pages

I would like to not only have pages, but give them a page number, you know, for that extra pizzaz.

The way to do this is probably to
 a) keep track of page numbers, see above
 b) give ~make-svg-rectangles~ the possibility of having a page number displayed
 c) give the big assigning function/minor mode the tools to assign it to it
#+begin_src emacs-lisp :tangle no
;; for the svg
(defun make-svg-rectangles h1 bg1 &opt page &rest other
       "yayayya"
       ;;let part
       ..
       ...
       ...
;; actual svg part
      (when page
       (svg-text svg
                 page ; maybe have options for roman numerals at some point
                 :font-size 60 ;idk
                 :x (round (/ (margin-width-pixel) 2))
                 :y (/ h1 2)
                 :text-anchor "middle"
                 :fill-color (foreground-color 'comment)
                 ))

       )
#+end_src


I want thing to be in the middle, and  with olivetti mode the fringes become larger so it looks like a word processor, fantastic!



#+begin_src emacs-lisp :tangle yes
(use-package! olivetti
  :after org
  ;:hook (olivetti-mode . double-header-line-mode)
  :config
    (setq olivetti-min-body-width 50
          olivetti-body-width 80
          olivetti-style 'fancy ; fantastic new layout
          olivetti-margin-width 12)
    (add-hook! 'olivetti-mode-hook (window-divider-mode -1))
    (add-hook! 'olivetti-mode-hook (set-face-attribute 'window-divider nil :foreground (face-background 'fringe) :background (face-background 'fringe)))
    (add-hook! 'olivetti-mode-hook (set-face-attribute 'vertical-border nil :foreground (face-background 'fringe) :background (face-background 'fringe)))
    )
#+end_src
*** Trying to get overviews
#+begin_src emacs-lisp :tangle yes
(require 'org-inlinetask)
#+end_src

#+begin_src emacs-lisp :tangle yes
;(use-package! org-sidebar
;  :after org
;  :config
  ;(setq org-sidebar-default-fns '(org-sidebar--todo-items))
  ;(add-hook! 'org-sidebar-window-after-display-hook (solaire-mode 1))
;   )
#+end_src
*************** TODO tasktask
*************** END

#+begin_src emacs-lisp :tangle yes
(after! org
  (remove-hook 'org-agenda-finalize-hook '+org-exclude-agenda-buffers-from-workspace-h)
  (remove-hook 'org-agenda-finalize-hook
               '+org-defer-mode-in-agenda-buffers-h))

(defun thomas/org-get-overview ()
  "Open outline and sidebar."
  (progn
    (org-ol-tree)
    (org-sidebar)))
#+end_src


*** STAY FOCUSED
 Pretty cool: focus only the paragraph you're looking at. Don't really use it though.
 #+begin_src emacs-lisp :tangle yes
(use-package! focus
  :after org-roam
  :config
        (add-to-list 'focus-mode-to-thing '(org-mode . paragraph))
  )
;(require 'nano-writer)
 #+end_src

*** My eyes, they don't work so good no more
 Increase the font-size a bit in org-mode

 FIXME: This is not how you do that dipshit
 This increas the font size every singe time you open an org file, not ideal.
 #+begin_src emacs-lisp :tangle no
(add-hook! 'org-mode-hook (doom/increase-font-size 1))
 #+end_src

** Custom org-mode profiles

I would like org-mode to look and behave differently depending on what kind of note I'm visiting. Sometimes I want to write in an undistracted environment, sometimes I want to take notes and see a lot of things, sometimes I am configuring this thing and other times I'm going through my tasks: there's no real reason for org to look the same for all of these, and in fact that will probably end up more distracting than anything.

I'm not sure what the best way of going about this is, but I'm thinking a minor mode will do.

#+begin_src emacs-lisp :tangle no
(define-minor-mode org-profile-mode
  "Sets a profile of hooks and minor-modes depending on the file-name."
  :init-value nil
  :global t
(when org-profile-mode
  (when (eq major-mode 'org-mode)
    (cond
      ((string-match-p "[0-9]\\{14\\}" buffer-file-name)
       (message "Note buffer"))
      ((string-match-p "config.org" buffer-file-name)
       (message "Config buffer"))
      ((string-match-p "chapter" buffer-file-name)
       (message "chapter buffer"))
      ((org-agenda-file-p buffer-file-name)
       (message "org-agenda buffer")
        ))
  )))
#+end_src

Something like: if file name contains YYYYMMDD-whatever.org, notes profile.
If file name is in org-agedenda, GTD profile.
Else, writing? No, would be better to have writing be a separate tag/file name thing.

You should be able to indefinitely add profiles. This could be a big list, but that would get kind of hard and I don't know how those work.

For now I can just hard code it, it's fine.


** Custom Minor Modes

   Guaranteed not stolen.
Thank you Prot
#+begin_src emacs-lisp :tangle yes
;;;;;


;;
;;    Custom Minor Modes
;;
;;;;;

(define-minor-mode prot/scroll-center-cursor-mode
  "Toggle centred cursor scrolling behavior"
  :init-value nil
  :lighter " S="
  :global nil
  (if prot/scroll-center-cursor-mode
      (setq-local scroll-margin (* (frame-height) 2)
                  scroll-conservatively 0
                  maximum-scroll-margin 0.5)
    (dolist (local '(scroll-preserve-screen-position
                     scroll-conservatively
                     maximum-scroll-margin
                     scroll-margin))
      (kill-local-variable `,local)))
  )


#+end_src


Make everything variable pitch, who the hell likes reading fixed-pitch?

#+begin_src emacs-lisp :tangle yes
(define-minor-mode prot/variable-pitch-mode
  "Toggle 'mixed-pitch-modei, except for programming modes"
  :init-value nil
  :global nil
  (if prot/variable-pitch-mode
      (unless (derived-mode-p 'prog-mode)
        (variable-pitch-mode 1))
    (variable-pitch-mode -1)))
#+end_src

NO line numbers.

#+begin_src emacs-lisp :tangle yes

(define-minor-mode prot/display-line-number-mode
  "Disable line numbers, except for programming modes."
  :init-value nil
  :global nil
  (if prot/display-line-number-mode
      (unless (derived-mode-p 'prog-mode)
        (display-line-numbers-mode -1))
    (display-line-numbers-mode 1)))
#+end_src

Throw everything together, but in a bad way.
I don't use this anymore, but it did work, except for nano's writing mode, which was very hacky.
#+begin_src emacs-lisp :tangle no
(define-minor-mode thomas/writing-mode
  "Toggle mixed-pitch-mode, center-text, scroll-center and disable line numbers, in writing modes."
  :init-value nil
  :global nil
  (if thomas/writing-mode
      (unless (derived-mode-p 'prog-mode)
        (nano/writer-mode 1)
        (prot/display-line-number-mode 1)
        (prot/variable-pitch-mode 1)
        (prot/scroll-center-cursor-mode 1)
        (olivetti-mode 1)
        (focus-mode 1)
        (org-fragtog-mode 1)
        (org-roam-buffer-deactivate)
        (hl-line-mode -1)
        (org-indent-mode -1)
        (minimap-mode)
        ;(centaur-tabs-mode -1)
        ;(org-mode-restart)
        )
        (prot/display-line-number-mode -1)
        (prot/variable-pitch-mode -1)
        (prot/scroll-center-cursor-mode -1)
        (nano/writer-mode -1)
        (olivetti-mode -1)
        (focus-mode -1)
        (org-fragtog-mode -1)
        ;(centaur-tabs-mode 1 )
        (org-indent-mode 1)
        (minimap-mode -1)
        ;;(org-mode-restart)

        ))

(defun thomas/writing-mode-fun ()
  "Toggle mixed-pitch-mode, center-text, scroll-center and disable line numbers, in writing modes."
  ;;(interactive)
  (org-superstar-mode -1)
  (require 'nano-writer)
  (writer-mode)
        (prot/display-line-number-mode 1)
        (prot/mixed-pitch-mode 1)
        (prot/scroll-center-cursor-mode 1)
        (olivetti-mode 1)
  )


#+end_src

*** Nano writer mode implementation, not used atm

  #+begin_src elisp :tangle no
(defun writer-mode--num-format (numbering)
  "Alternative numbering format for org-num.
First level: 1 | xxx
Second level: 1.1 — xxx
Third level: 1.1.1 - xxx
etc."
  (if (= (length numbering) 1)
      (propertize (concat (mapconcat
                           #'number-to-string
                           numbering ".") " | " )
                  'face `(:family "Roboto Condensed"
                          :height 250
                          :foreground ,nano-color-faded))
    (propertize (concat (mapconcat
                         #'number-to-string
                         numbering ".") " — " )
                'face `(:family "Roboto Condensed"
                        :foreground ,nano-color-faded))))

;; Specific face for headline stars
;(font-lock-add-keywords 'writer-mode
;             '(("^*+ " 0 `(:family "Roboto Mono"
;                           :height 140
;                           :foreground ,nano-color-faded) prepend)
;               ) 'append)

(defun writer-mode--compute-prefixes ()
  "Compute prefix strings for regular text and headlines."

  (setq org-indent--heading-line-prefixes
        (make-vector org-indent--deepest-level nil))
  (setq org-indent--inlinetask-line-prefixes
        (make-vector org-indent--deepest-level nil))
  (setq org-indent--text-line-prefixes
        (make-vector org-indent--deepest-level nil))

  (let* ((min-indent 5)
         (indent (+ 1 (seq-max
                  (org-element-map
                      (org-element-parse-buffer) 'headline
                    #'(lambda (item)
                        (org-element-property :level item))))))
         (indent (max indent min-indent)))

  (dotimes (n org-indent--deepest-level)
    (aset org-indent--heading-line-prefixes n
          (make-string
           (min indent (max 0 (- indent 1 n))) ?\s))
    (aset org-indent--inlinetask-line-prefixes n
          (make-string indent ?\s))
    (aset org-indent--text-line-prefixes n
          (make-string indent ?\s)))))



(define-minor-mode nano/writer-mode
  "Minor mode which makes writing a lot nicer by moving all the headllines to the left."
  :init-value nil
  :global nil
  ;; Faces
  (face-remap-add-relative 'org-level-1
                           :height 180)
  (face-remap-add-relative 'org-level-2
                            :height 160)
  (face-remap-add-relative 'org-level-3
                            :height 150)
  (face-remap-add-relative 'org-document-info
                           :inherit 'nano-face-faded)
  (face-remap-add-relative 'org-document-title
                           :foreground (face-foreground 'default)
                           :family "Roboto Slab"
                           :height 200
                           :weight 'medium)
  ;; hide title / author ... keywords
  (setq-local org-hidden-keywords '(title author date startup))

  ;; Header line
  (setq header-line-format nil)

  ;; Layout
  (setq fill-column 72)
  (setq-default line-spacing 1)

  ;; Indentation
  (setq org-startup-folded nil)
  (org-indent-mode)
  (setq org-level-color-stars-only nil)
  (setq org-hide-leading-stars nil)
  (advice-add 'org-indent--compute-prefixes :override
              #'writer-mode--compute-prefixes)

  ;; Numbering
  (setq org-num-skip-unnumbered t)
  (setq org-num-skip-footnotes t)
  (setq org-num-max-level 3)
  (setq org-num-face nil)
  (org-num-mode)
  (setq org-num-format-function 'writer-mode--num-format))

;; Fringe shit
;;

  #+end_src

*** Trying to make olivetti-mode better, and failing
 #+begin_src emacs-lisp :tangle no
(setq solaire-mode-remap-fringe nil)
;(set-face-background 'solaire-fringe-face (face-background 'solaire-hl-line-face))


(setq thomas-fringe-size 500)
(setq thomas-margin-size 10)
;  "Variable which sets the size of the fringes."
;  :type 'integer
;  :group 'thomas-aesthetics)

(after! solaire-mode
  (define-minor-mode thomas-fringe-mode
  "Minor mode to hide the mode-line in the current buffer."
  :init-value nil
  :group 'thomas-aesthetics
  (if (not thomas-fringe-mode)
      (progn
        (set-face-background 'solaire-fringe-face (face-background 'solaire-default-face))
        (setq left-fringe-width nil
              right-fringe-width nil))
    (progn (set-face-background 'solaire-fringe-face (face-background 'solaire-hl-line-face))
      (setq left-fringe-width thomas-fringe-size
            right-fringe-width thomas-fringe-size
            left-margin-width thomas-margin-size
            right-margin-width thomas-margin-size)))))

;(add-hook! 'org-mode-hook #'thomas-fringe-mode)
(add-hook! thomas-fringe-mode-hook (custom-set-faces! '(solaire-fringe-face :background (face-background))))
;(setq solaire-mode-remap-fringe nil)


 #+end_src

** Org-latex export

Why does it not simply do what I intend?
#+begin_src emacs-lisp :tangle yes
                ;;;;;;;;
;;
;; org-latex-export
;;
;;;;;;;;

(after! org
   (add-to-list 'org-latex-classes
                '("tufte"
                  "\\documentclass{tufte-book}"
                  ("\\part{%s}" . "\\part*{%s}")
                  ("\\chapter{%s}" . "\\chapter*{%s}")
                  ("\\section{%s}" . "\\section*{%s}")
                  ("\\subsection{%s}" . "\\subsection*{%s}")
                  ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
   (add-to-list 'org-latex-classes
                '("memoir"
                  "\\documentclass{memoir}"
                  ("\\part{%s}" . "\\part*{%s}")
                  ("\\chapter{%s}" . "\\chapter*{%s}")
                  ("\\section{%s}" . "\\section*{%s}")
                  ("\\subsection{%s}" . "\\subsection*{%s}")
                  ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
                )
    (setq org-latex-text-markup-alist '((bold . "\\textbf{%s}")
                                        (code . protectedtexttt)
                                        (italic . "\\emph{%s}")
                                        (strike-through . "\\sout{%s}")
                                        (underline . "\\uline{%s}")
                                        (verbatim . "{\\color{red}%s}")))
(setq org-latex-default-packages-alist
      '(
 ;("AUTO" "inputenc" t
 ; ("pdflatex"))
 ;("T1" "fontenc" t
 ; ("pdflatex"))
 ("utf8" "inputenc" nil)
 ("" "graphicx" t)
 ("" "grffile" t)
 ("" "longtable" nil)
 ("" "wrapfig" nil)
 ("" "rotating" nil)
 ("normalem" "ulem" t)
 ("" "amsmath" t)
 ("" "textcomp" t)
 ("" "amssymb" t)
 ("" "capt-of" nil)
 ("style=apa, backend=biber" "biblatex" nil)
 ("" "braket" nil)
 ("" "xcolor" nil)
 ("" "hyperref" nil))
)
(setq  org-latex-pdf-process
       '("latexmk -shell-escape -bibtex -pdf %f -f")
       org-latex-compiler "xelatex"
       org-latex-bib-compiler "biber")
    )
    ;(add-to-list 'org-latex-default-packages-alist
    ;             '("" "xcolor" nil))
    ;(add-to-list 'org-latex-default-packages-alist
    ;             '("" "braket" nil))
    ;(add-to-list 'org-latex-default-packages-alist '("style=apa, backend=biber" "biblatex" nil)))
    ;(setq org-format-latex-header (concat org-format-latex-header "\n\\")))


#+end_src




* Latex
My eternal enemy

** Compilation
I almost always want to fuck around with the fonts, so XeTeX is pretty much necessary. Although I would really like to learn LuaTex, I just haven't really seen any cool usecases of it.
#+begin_src emacs-lisp :tangle yes
(add-hook! 'latex-mode-hook (setq TeX-engine 'xetex) 99)

    ;  (call-process TeX-shell nil (TeX-process-buffer-name file) nil
     ;               TeX-shell-command-option (concat command file))))
#+end_src

#+begin_src emacs-lisp :tangle yes
(after! latex
(defun latex-dwim ()
  "Compile the current file if it's a .tex file using LaTeXMK.
Otherwise compile the TeX file with the same name as the current TeXey file,
such as a .cls or .bib.
Otherwise compile all the .tex files you find using LaTexMK."
  (interactive)
  (save-buffer)
  (if-let ((files (thomas/find-tex-file))
           (command
            "latexmk -pdf -pdflatex=lualatex --synctex=1 -interaction=nonstopmode  -file-line-error ")
        (hook (nth 2 (assoc "LatexMk" TeX-command-list))))
      (if (stringp files)
      (TeX-run-format "LatexMk" (concat command files) files)
        (dolist (file files)
      (TeX-run-format "LatexMk" (concat command file) file)))
    (message "No file found, whoops.")))

(defun thomas/find-tex-file ()
  "Find the correct TeX file(s)."
  (let* ((fname (buffer-file-name))
         (ext (file-name-extension fname))
         (potential-main  (f-join (f-slash (f-parent fname)) (concat (f-base fname) ".tex")))
         (alltex (f-entries (f-parent fname) (lambda (f) (f-ext-p f "tex"))))
    (correct-file
     (cond ((string= ext "tex")
           fname)
           ((seq-contains-p '("bib" "cls" "sty") ext)
            (if (f-exists-p potential-main)
                potential
              alltex))
           (t nil))))
    correct-file)))
#+end_src

#+begin_src emacs-lisp :tangle yes
(map! :map 'doom-leader-regular-map
      :desc "LatexMk dwim" "l" #'latex-dwim)
#+end_src
#+RESULTS:
: thomas/find-tex-file

* Project management
** Treemacs
Pretty useful, and looks cool. I almost always want it on, so let's just add a hook for that.

#+begin_src emacs-lisp :tangle yes
(add-hook! 'after-init-hook #'treemacs)
#+end_src

Get rid of that fugly divider
#+begin_src emacs-lisp :tangle yes
(after! treemacs
(add-hook! 'treemacs-mode-hook (setq window-divider-mode -1
                                     variable-pitch-mode 1
                                     treemacs-follow-mode 1))
)
#+end_src
* Programming
** Regex

Emacs regex sucks. Luckily, there are packages which make this much better, including making changes visual.

#+begin_src emacs-lisp :tangle yes
(use-package! visual-regexp
  :config
        (map! :map 'doom-leader-regular-map
              (:prefix ("v" . "visual regex")
               :desc "Replace regexp" "r"#'vr/replace)))

(use-package! visual-regexp-steroids
  :after 'visual-regexp)
#+end_src
** Docs
#+begin_src emacs-lisp :tangle yes
(use-package! devdocs
  :after lsp
  :config
  (add-hook! 'devdocs-mode-hook
    (face-remap-add-relative 'variable-pitch '(:family "Noto Sans"))))
#+end_src
** LSP
LSP auto format is nice, but not as configurable as prettier, better let prettier handle it.
#+begin_src emacs-lisp :tangle yes
(add-hook! 'after-init-hook
           (progn
  (setq-hook! 'typescript-mode-hook +format-with :nil)
  (add-hook! 'typescript-mode-hook 'prettier-mode)
  (setq-hook! 'rjsx-mode-hook +format-with :nil)
  (add-hook! 'rjsx-mode-hook 'prettier-mode)
  (setq-hook! 'js2-mode-hook +format-with :nil)
  (add-hook! 'js2-mode-hook 'prettier-mode)
  (setq-hook! 'typescript-tsx-mode-hook +format-with :nil)
  (add-hook! 'typescript-tsx-mode-hook 'prettier-mode)
  ))
#+end_src

* EVA

The future is here.
#+begin_src emacs-lisp :tangle yes

(use-package! eva
:init
(setq ess-history-file "~/OneDrive/self/data/.Rhistory")
(setq ess-ask-for-ess-directory nil)
  (setq eva-ai-name "Ea"
        eva-user-name "Thomas"
        eva-user-birthday "2021-07-16"
        eva-user-short-title "Bruh"
        eva-fallback-to-emacs-idle t)
      (setq eva--idle-secs-fn #'eva--idle-secs-gnome)
  (setq eva-idle-log-path         "~/OneDrive/self/data/idle.tsv")
  (setq eva-buffer-focus-log-path "~/OneDrive/self/data/buffer-focus.tsv")
  (setq eva-buffer-info-path      "~/OneDrive/self/data/buffer-info.tsv")
  (setq eva-main-ledger-path      "~/OneDrive/self/journal/finances/l.ledger")
  (setq eva-main-datetree-path    "~/OneDrive/org-roam/diary.org")
  :config
  (setq org-journal-dir "~/OneDrive/org-roam/journal")
    (setq org-journal-file-format "%F.org")
    (require 'eva-builtin)
  (require 'eva-activity)
    (add-hook 'eva-after-load-vars-hook #'eva-check-dangling-clock)
  (add-hook 'eva-after-load-vars-hook #'eva-check-org-variables)
   (setq eva-items
        (list
         (eva-item-create :fn #'eva-greet
                          :min-hours-wait 1)

         (eva-item-create :fn #'eva-query-mood
                          :dataset "~/OneDrive/self/data/mood.tsv"
                          :min-hours-wait 1)

         (eva-item-create :fn #'eva-query-activity
                          :dataset "~/OneDrive/self/data/activities.tsv"
                          :min-hours-wait 1)

         (eva-item-create :fn #'eva-present-diary
                          :max-successes-per-day 1)

         (eva-item-create :fn #'eva-query-weight
                          :dataset "~/OneDrive/self/data/weight.tsv"
                          :max-entries-per-day 1)

         (eva-item-create :fn #'eva-plot-weight
                          :max-entries-per-day 1)

         (eva-item-create :fn #'eva-query-sleep
                          :dataset "~/OneDrive/self/data/sleep.tsv"
                          :min-hours-wait 5
                          :lookup-posted-time t)

         (eva-item-create :fn #'eva-present-ledger-report)

         (eva-item-create :fn #'eva-present-org-agenda)

         (eva-item-create :fn #'eva-query-ingredients
                          :dataset "~/OneDrive/self/data/ingredients.tsv"
                          :min-hours-wait 5)

         (eva-item-create :fn #'eva-query-cold-shower
                          :dataset "~/OneDrive/self/data/cold.tsv"
                          :max-entries-per-day 1)

         ;; you can inline define the functions too
         (eva-item-create
          :fn (eva-defun my-bye ()
                (message (eva-emit "All done for now."))
                (bury-buffer (eva-buffer-chat)))
          :min-hours-wait 0)))
        (transient-replace-suffix 'eva-dispatch '(0)
    '["General actions"
      ("q" "Quit" bury-buffer)
      ("l" "View Ledger report" eva-present-ledger-report)
      ("f" "View Ledger file" eva-present-ledger-file)
      ("a" "View Org agenda" org-agenda-list)])

  (define-key eva-chat-mode-map (kbd "l") #'eva-present-ledger-report)
  (define-key eva-chat-mode-map (kbd "a") #'org-agenda-list)

  ;; Activities
  (setq eva-activity-list
        (list (eva-activity-create :name "sleep"
                                   :cost-false-pos 3
                                   :cost-false-neg 3)

              (eva-activity-create :name "studying"
                                   :cost-false-pos 8
                                   :cost-false-neg 8)

              (eva-activity-create :name "coding"
                                   :cost-false-pos 5
                                   :cost-false-neg 5)

              (eva-activity-create :name "working"
                                   :cost-false-pos 5
                                   :cost-false-neg 5)
              (eva-activity-create :name "unknown"
                                   :cost-false-pos 0
                                   :cost-false-neg 0)))
  (eva-mode))
#+end_src
* Some other things, such as vterm
** Mail

#+begin_src emacs-lisp :tangle no
(require 'nano-mu4e)
(require 'nano-agenda)
#+end_src

Misc
#+begin_src elisp :tangle yes
        ;;;;;;;;;;;;;
;;;
;;; Other
;;;
;;;;;;;;;;;;

(setq vterm-shell "/usr/bin/fish")

(setq evil-escape-key-sequence "qd")

#+end_src

I would like to use tree-sitter instead of font-lock, but it does not really work well with .tsx and org-mode, so for now it will remain here.
#+begin_src emacs-lisp :tangle yes

;(use-package! tree-sitter
;  :config
;  (require 'tree-sitter-langs)
;  (global-tree-sitter-mode)
;  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))


;(use-package tree-sitter-langs
;  :ensure t
;  :after tree-sitter
;  :config
; (tree-sitter-require 'tsx)
;(add-to-list 'tree-sitter-major-mode-language-alist '(typescript-tsx-mode . tsx)))
#+end_src

Colors in the info box, jeej.
#+begin_src emacs-lisp :tangle yes
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)

#+end_src

* Keyboard shortcuts

** Great keybindings by moi

I just map everything to SPC-r because doom is not using it and r stands for roam.
#+begin_src elisp :tangle yes
(map! :leader
      (:prefix-map ("r" . "regular")
       :desc "find file"            "f"   #'org-roam-node-find
       :desc "find ref"             "F"   #'org-roam-ref-find
       :desc "center scroll"        "s"   #'prot/scroll-center-cursor-mode
       :desc "start taking notes"   "S"   #'org-noter
       :desc "toggle buffer"        "b"   #'org-roam-buffer-toggle
       :desc "insert note"          "i"   #'org-roam-node-insert
       :desc "server"               "g"   #'org-roam-server
       :desc "quit notes"           "q"   #'org-noter-kill-session
       :desc "tag (roam)"           "t"   #'org-roam-tag-add
       :desc "tag (org)"            "T"   #'org-set-tags-command
       :desc "pomodoro"             "p"   #'org-pomodoro
       :desc "change nano-theme"    "n"   #'nano-toggle-theme
       :desc "rebuid db"            "d"   #'org-roam-db-build-cache
       :desc "cite"                 "c"   #'helm-bibtex
       :desc "thesaurus this word"  "w"  #'powerthesaurus-lookup-word-at-point
       :desc "thesaurus lookup word" "W"   #'powerthesaurus-lookup-word
       :desc "outline"              "o"   #'org-ol-tree
       (:prefix  ("r" . "orui")
                :desc "orui-mode" "r" #'org-roam-ui-mode
                :desc "zoom" "z" #'orui-node-zoom
                :desc "open" "o" #'orui-open
                :desc "local" "l" #'orui-node-local
                :desc "sync theme" "t" #'orui-sync-theme
                :desc "follow" "f" #'orui-follow-mode)
       (:prefix ("m" . "transclusion")
                :desc "make link"            "m"   #'org-transclusion-make-from-link
                :desc "transclusion mode"    "t"   #'org-transclusion-mode
                :desc "add at point"         "a"   #'org-transclusion-add-at-point
                :desc "add all in buffer"    "A"   #'org-transclusion-add-all-in-buffer
                :desc "remove at point"      "r"   #'org-transclusion-remove-at-point
                :desc "remove all in buffer" "R"   #'org-transclusion-remove-all-in-buffer
                :desc "start live edit"      "s"   #'org-transclusion-live-sync-start-at-point
                :desc "stop live edit"       "S"   #'org-transclusion-live-sync-exit-at-point)
       )
      (:prefix ("d" . "GTD")
       :desc  "process inbox" "p"#'org-gtd-process-inbox
       :desc  "agenda list" "a"#'org-agenda-list
       :desc  "capture" "c"#'org-gtd-capture
       :desc  "show next" "n" #'org-gtd-show-all-next
       :desc  "show stuck project" "s" #'org-gtd-show-stuck-projects)
      )
#+end_src

#+RESULTS:
: org-gtd-show-stuck-projects

** Window movement
The default window movement keys are super cumbersome, here are some better defaults.

#+begin_src emacs-lisp :tangle yes
(map! "C-w" nil)
(global-set-key  (kbd "C-<tab>") #'evil-window-next)
 (global-set-key             (kbd "C-<iso-lefttab>") #'evil-window-prev)
     (global-set-key   (kbd "C-w") #'ace-window)

(map!
    :nvig "C-<iso-lefttab>" #'evil-window-prev
      :nvig  "C-w" #'ace-window)
(map! :nvig "C-<tab>" #'evil-window-next)
#+end_src

** Selection
Wow, I wish I knew this was a thing before

#+begin_src emacs-lisp :tangle yes
(map!  :nvig "C-'" #'er/expand-region)
#+end_src

** Workman

   I use the Workman keyboard layout, this package sets most of the evil shortcuts to more sensible positions. I still need to add some more specific shortcuts, for instance for moving windows.
#+begin_src emacs-lisp :tangle yes
(evil-workman-global-mode t)
 #+end_src

#+begin_src emacs-lisp :tangle no
(evil-define-key '(normal)
    "n"         'evil-next-visual-line
    "e"         'evil-previous-visual-line
    )
#+end_src
This does not fix the window bindings, so we have to do that manually

#+begin_src emacs-lisp :tangle yes
(map!
 :map evil-window-map
      "y" #'evil-window-left
      "Y" #'+evil/window-move-left
      "n" #'evil-window-down
      "N" #'+evil/window-move-down
      "e" #'evil-window-up
      "E" #'+evil/window-move-up
      "o" #'evil-window-right
      "O" #'+evil/window-move-right)
#+end_src


This does not apply them to org-mode, which uses evil-org.el, but those are easily customized

#+begin_src emacs-lisp :tangle yes

(defun set-evil-keybindings ()
  (progn
  ;(iscroll-mode 1)
  (setq evil-org-movement-bindings
        '((up . "e")
          (down . "n")
          (left . "y")
          (right . "o")))
  (evil-define-key 'normal evil-org-mode-map
    "o"         'evil-forward-char
    "l"          'evil-org-open-below
    "L"         'evil-org-open-above
    "gy"        'org-backward-element
    "gn"        'org-down-element
    "ge"        'org-up-element
    "go"        'org-forward-element
    "n"         'evil-next-visual-line
    "e"         'evil-previous-visual-line
;    "n"         'iscroll-forward-line
;    "e"         'iscroll-previous-line
    "N"         'evil-next-line
    "E"         'evil-previous-line
    (kbd "C-n") 'follow-scroll-up
    (kbd "C-e") 'follow-scroll-down
    "zn"        '+org-tree-to-indirect-other-window
    "zs"        '+org-tree-to-indirect-current-window
    "zv"        '+org-tree-to-indirect-other-frame)
  ))

(after! org (set-evil-keybindings))

;; JUST TO BE REALLY FUCKING SURE
(add-hook 'org-mode-hook #'set-evil-keybindings 99)
(defun iscroll-mode-keybinds ()
  (when (eq iscroll-mode t)
      (evil-define-key 'normal evil-org-mode-map
        "n" 'iscroll-forward-line
        "e" 'iscroll-previous-line)))
          #+end_src
#+begin_src emacs-lisp :tangle no
(add-hook! 'org-mode-hook #'iscroll-mode)
(add-hook! 'iscroll-mode-hook #'iscroll-mode-keybinds)
#+end_src

** Ivy

#+begin_src emacs-lisp :tangle yes
(use-package! all-the-icons-ivy-rich
  :init (all-the-icons-ivy-rich-mode))
#+end_src
** Markdown
Add .mdx support
#+begin_src emacs-lisp :tangle yes
 (add-to-list 'auto-mode-alist '("\\.mdx\\'" . markdown-mode))
#+end_src`
* Custom functions I keep using

** Get margin width in pixel
#+begin_src emacs-lisp :tangle yes
(defun margin-width-pixel (&optional right)
  "Return the width of the left or optionally right margin in pixels."
  (if (window-margins)
     (if right
           (* (frame-char-width) (cdr (window-margins))) ;;right margin
          (* (frame-char-width) (car (window-margins))))
          0))
#+end_src
** Refresh org-latex
#+begin_src emacs-lisp :tangle yes
(defun org-latex-refresh ()
  (interactive)
  (progn
  (org-clear-latex-preview)
  (org--latex-preview-region (buffer-end -1) (buffer-end 1))))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun org-latex-clear-preview ()
  (interactive)
  (org-clear-latex-preview))
#+end_src
* To configure

** Some packages to check out

   Binder
   Org-marginalia
   ...

** Tweaks I want to make
   Make olivetti mode margins  scale with the text size better

   Smaller headings, they are a bit ridiculous.
   Zoom in a bit by default.

** TODO Set org env based on title

   I want some way to have emacs recognize settings based on either the title of the org file or its tags. The way I set things up is not conducive for every situation.
*** GTD

    Not sure yet.
*** Config

    Colorful theme so you can see the parentheses well.
    No flyspell etc.

*** Notes

    Less extreme distraction freeness, possibility to open multiple notes
    Sans serif
    Nroam/org-roam-buffer
    Little EAF window with the map
    Treemacs?

*** Writing

    Distraction free layout with olivetti
    Org num
    Marginalia
    Serif
** PAGES

*** Iscroll

    Works, but "forward-line" is very slow compared to "evil-next-visual-line", should make that compatible with both.
* Server
Emacs daemon gives me nothing but headaches. This is not ideal, but it at least works.
#+begin_src emacs-lisp :tangle yes
(server-start)
#+end_src
